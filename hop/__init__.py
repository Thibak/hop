# -*- coding: utf-8 -*-
"""
@author: russinow
"""
from core import Engine
from DataDriver import XMLDriver, DataMachine
from subprocess import call
from code import interact 

 

# Создаем болванку для общедоступности
ex = None
ex_path = 'experiments/'
mod_path = 'models/'

#--------------------------------------
# хелпы:
# два штуки: графика, новый файл

new_task_help =\
"""
Для создания нового задания задайте следующие параметры:
Как префикс используйте ex.
- setModel(name):
задает имя модели -- имя файла .py с описанием структуры модели. Имя файла может иметь или не иметь расширения .py, программа автоматически дополняет имя до полного. В том случае если путь к файлу непосредственно не задан, и указано только имя, программа производит поиск во внутренней директории ./models, в том случае, если такого файла нет, пользователю предлагается задать абсолютный путь к файлу, или создать файл с таким именем во внутренней директории. 
На одну модель может ссылаться много программ эксперимента. Расчеты не вносят изменений в программу эксперимента.
- makeMatrix(Xvar, XX, Yvar, YY): создает декартово произведение параметров Xvar*Yvar по векторам XX, YY. Вектора создаются процедурой np.arange(start, stop, step)
- makeVec(Xvar, XX): создает вектор по переменной Xvar, из вектора XX, XX задается процедурой np.arange(start, stop, step)
Задание не может содержать более одной матрицы или вектора. Попытка создания нового блокируется.
- delTask(): Однако до начала расчета задание может быть удалено и создано новое (с заменой типа задачи и итерируемых параметров) 
"""

graph_help =\
"""
Для работы с графикой доступны следующие функции:
Как префикс используйте ex.
-
-
-

""" 
#----- болванка для модели (нуль-модель)
null_model = """
#########################################################
############# Модель системы кроветсоврения #############
#########################################################
# Гайдлайн по написанию модели
# Описание:
# все функции вызываются как методы класса e. (* точнее e является сущностью класса XMLDriver)
# Константы должны определяться в виде e.const.имя_константы = значение
# Модель состоит из двух частей: модуль клеточной динамики и блочной модели
# Для описания первого служит система состояний (Condition). Состояние состоит из названия сосоятония клетки и вектора событий (Event).
# для добавления события служит вызов функции
# e.addCondition(name, vec)
# Каждое событие описывается парой функций: функционал и результат события.
# Формат: [Event('функция','результат'), ...]
# Функционал является случайной функцией возвращающей время до события. Для использования доступны любые алгеброические функции и пр. доступное в библиотеке numpy, в частности рекомендуется использование библиотеки random и numpy.random, и в частности numpy.random.weibull
# Управляющие обратные связи работают через сервер обратных связей. О добавлении значений написано ниже, здесь же оговорим возможность использования значения из слотов сервера обратных связей. Слоты возвращают значение в зависимости от подключенного словаря. Обращение к слотам происходит через функцию self.Engine.FB.val(имя слота)
<----может быть стоит сделать какие-то шортхенды для этого 
# функционал вычисляется для всех возможных событий, определяется ближайший и закладывается в Сервер Событий, когда приходит время для события, выполняется вторая строка
# Для второй строки доступны следующие функции (не забывать префикс self.):
# - sleep() 
# - division()
# - assymDivision(name) -- имя состояния для второй клетки
# - differentiation(cmprt) -- имя состояния куда переходит клетка
# - apoptosys()
# - toMature()
# Хитрость состоит в том, что действие выполняется по прошествии времени. Например действие sleep, не делает ничего кроме выбрасывания нового времени. Это значит, что клетка "проспола" это время.
# Т.к. управление происходит "изнутри" клетки, вызов происходит с префиксом self.
#
# Кроме того, для использования доступны управляющие события. Т.к. управление происходит "изнутри" клетки, то использовать необходимо абсолютный адресс:
# self.Engine.
#  
# После того, как все состояния созданы, необходимо задать начальное состояние для клеток. e.setDefCond(name)
#  
№
# Управление сервером обратных связей:
# e.FB.
#  -  addDict(name, dict = {}) -- где dict - словарь, т.е. пары имя_слота:строка_для_выполнения. Имя слота -- имя по которому происходит обращение из событий, строка -- функционал, возвращающий управляющее значение. В общем случае может содержать все, что угодно. В частном предпологается использование сумматоров из компартментов по формату:
# self.MCC[name].n и self.SCC[name].n -- количество клеток в компартменте с таким-то именем. Естественно, возможно суммирование по всем компартментам для списков, какие-то генераторы и пр.
#  -  addSlot(name, dict, string) -- вообще не понятно зачем, т.к. есть общая функция, но для полноты она имеется. Добавляет слот к созданному ранее словарю. Причем если такого нет, то программа вылетает.
# При создании сервера обратных связей автоматически словарем по умолчанию становится пустой словарь default, потому необходимо его переопределить функцией:
# self.Engine.FB.changeDict(имя словаря)
# Добавление псевдособытия
# в основном псевдособытия предназначены для переключения словарей обратных связей, т.е. замена словаря-болванки (начальные значения), рабочей версией обратных связей. Отдельное переключение слотов не пердпологается. 
# Контейнеры у меня крайне умные, и сами добавляется в сервер событий, потому вполне достаточно их создать
# 1. Абстрактный контейнер события (например генерирующий клетку-мутанта) -- EventContainer(Time, st), принимающий на вход время, когда он должен быть выполнен и строку, что собственно он должен сделать.

# 2. стоп-машина StopEvent(Time). Без такого события расчет длится бесконечно. Если клетки не элиминируют естественно. Удобен простотой вызова
#
# 
# Блочная часть модели:
# На входе весь граф блоков принимает dt от событийного куска, и производит перерасчет содержимого по формулам внутреннего (internal) и внешнего (transition) перехода. Под внешним переходом подразумевается количество переходящих в to узел графа. Хорошо бы, что бы небыло висячих концов  
# addCompartment(self, name, internal, transition, to):
# Функции для обоих переходов могут зависить от N (объем компартмента) и dt (дельта времени)
#
#
#
#----------------- метаинформация о модели ---------------------
# Что характерно, нижеследующие операции имеют префикс ex. т.к. это команды для драйвера данных. 
# - setIter(iteration): задает количество итерации для одного раунда монтекарло
# - addVScript(script): задает скрипт монтекарловской обработки векторных (множество реализации скаляров) данных
# - addSScript(script): задает скрипт монтекарловской обработки матричных (множество реализации векторов) данных
# о форматировании скриптов стоит написать отдельно
#
# 
#
#
#
#
#
#
#########################################################

"""


#----- блок работы с файлом -----  

def load(filename):
    global ex
    if '/' not in filename:
        filename = ex_path + filename
    try:
        ex = XMLDriver(filename)
    except IOError:
        print('No such file\n')
        yn = raw_input("Вы хотите создать файл с таким именем? \n(y/n):")
        if   yn == 'y' or 'Y' or 'у' or 'У' or 'yes' or 'д' or 'Д' or '':
            new(filename)
        else:
            print('Программа закрывается, досвидания')


def start():
    global ex
    """
    Запускаем рассчет по иксемелю
    Вначале каждого варианта надо выводить информацию о файле, полную.
    """
    if ex == None:
        print("""
        XML file not loaded. Please load or make new
            - load(filename)
            - new()        
        """)
    elif ex.status() == 'complete':
        print ex
        yn = raw_input("Расчет завершен. Прейти в интерактивный режим для построения графики?\n(y/n):")
        if   yn == 'y' or 'Y' or 'у' or 'У' or 'yes' or 'д' or 'Д' or '':
            print graph_help
            interact(local=locals()) # перейти в интерактивный режим, вывести хелп по графике
        elif yn == 'n' or 'N' or 'No' or 'x' or 'X' or 'exit' or 'quit' or 'q' or 'Q':
            return
        else:
            print('Что-то не то. Закрываюсь.')
    elif ex.status() == 'progress':
        print ex        
        yn = raw_input("Расчет завершен на " + str(ex.progress()) + "%, продолжить расчет?\n(y/n/число прогонов):")
        # селектор
        if   yn == 'y' or 'Y' or 'у' or 'У' or 'yes' or 'д' or 'Д' or '':
            calculation(ex)# начать выполнение
        elif yn == 'n' or 'N' or 'No' or 'x' or 'X' or 'exit' or 'quit' or 'q' or 'Q':
            return
        else:
            try: 
                n = int(yn)
                if n<0:
                    raise SyntaxWarning
            except SyntaxWarning:
                print ('количество операций не может быть меньше нуля')
                break
            except ValueError:
               print('Что-то не то. Закрываюсь.') 
            else:
                calculation(ex,n)# начать выполнение
            
    elif ex.status() == 'Null':
        print ex
        yn = raw_input("Это только заготовка, Вы хотите создать задание?\n(y/n):")
        # селектор
        if   yn == 'y' or 'Y' or 'у' or 'У' or 'yes' or 'д' or 'Д' or '':
            print new_task_help            
            interact(local=locals()) # перейти в интерактивный режим, вывести хелп по созданию задания
        elif yn == 'n' or 'N' or 'No' or 'x' or 'X' or 'exit' or 'quit' or 'q' or 'Q':
            return
        else:
            print('Что-то не то. Закрываюсь.')
                

    elif ex.status() == 'task':
        print ex
        yn = raw_input("Задание на расчет. Начать выполнение?\n(y/n/количество итераций):")
        # селектор
        if   yn == 'y' or 'Y' or 'у' or 'У' or 'yes' or 'д' or 'Д' or '':
            calculation(ex)# начать выполнение
        elif yn == 'n' or 'N' or 'No' or 'x' or 'X' or 'exit' or 'quit' or 'q' or 'Q':
            return
        else:
            try: 
                n = int(yn)
                if n<0:
                    raise SyntaxWarning
            except SyntaxWarning:
                print ('количество операций не может быть меньше нуля')
                break
            except ValueError:
                print('Что-то не то. Закрываюсь.') 
                break
            else:
                calculation(ex,n)# начать выполнение
    else:
        print ex
        yn = raw_input('Что-то не то... Попробуйте другой файл, или поправьте этот вручную\n Поправить вручную/посмотреть/выйти: (e/c/x)')
        if   yn == 'e' or 'E' or 'Е' or 'е' or 'edit':
            call("notepad "+ str(ex.filename))
        elif yn == 'c' or 'с' or 'C' or 'С' or 'check':
            call(str(ex.filename))
        elif yn == 'x' or 'х' or 'X' or 'exit' or 'quit' or 'q' or 'Q':
            return
        else:
            print('Что-то опять не то. Закрываюсь.')

def new(filename):
    global ex
    if '/' not in filename:
        filename = ex_path + filename
    ex = XMLDriver()
    ex.new(filename)
    print new_task_help
        
     
# Итератор рассчета
def calculation(exp, n = float('inf')):
    # проверка статуса модели 
    #примерная структура вычислителя:
#1. загружаем файл структуры модели
    # а вернее компилируем, т.к. в течении запуска надо каждый раз обновлять его 
    model = compile(open(exp.modelFN).read(),exp.modelFN,'exec') 
    #ВНИМАНИЕ!! После компиляции содержимое файла уже не модифицируется, т.ч. надо это учесть при итерировании
#2. загружаем параметры модели (таск) ПЕРВЫЙ ЦИКЛ 
    # т.е. загружаем его как текущуий таск для данного эксперимента
    while n != 0:
        n -= 1
        try:
            exp.LoadTask() # <--- НЕ ЗАБЫТЬ, что тут надо делать трай, т.к. обработка идет до эксепшена, вырабатываемого этой функцией. Т.е. while True, do.
    #3. формируем монтекарловские переменные
            # МК переменные вытаскиваются из модели, это значит делаем это циклом
            # нулевой цикл, для определения имен переменных в ДатаКоллекторе
            DM = DataMachine()
            DM.LoadScripts(exp) # загружаем скрипты 
            e = Engine()
            # НЕ запускаем модель, а только загружаем, для опрпделения типов, можно сделать стоп с нулевым временем....
            exec(model,locals())
            #e.start()
            
            # запускаем сортировщик
            DM.AnalizeModel(e.DC.data.dict)
        #4. формируем монтекарловский цикл
               
            for MKiter in range(exp.iterations):
        #5. создаем ядро
                e = Engine()
                # запускаем модель
                exec(model,locals())#<-- загружаем в локальный неймспейс
                
                # ВАЖНО!! Догрузка итерируемых параметров, а на самом деле перегрузка.
                e.const.__dict__.update(exp.loadConst())
                
        #7. запускаем расчет
                e.start()
        #8. останов расчета по критерию (какому? Допилить в ядре. Прописывается в модели, кстати)
                #сбор данных
                DM.addData(e.DC)
        #9. подсчет монтекарловских величин
            DM.CollapseData()  
            DM.PushData(exp)
        except IndexError:
            print "No more tasks, load interactive shell..."
            print graph_help
            interact(local=locals())
        except:
            print "somthing wrong."
    #10. конец
    
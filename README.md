hop
===

hematopoiesys on Python

Архитектура библиотек питона диктует двухуровневую иерархизацию. Т.е. в любом случае есть пакет, и есть егоо муодули. Из модулей мы можем подгружать функции. Однако, в __init__.py есть возможность прописать прямой импорт класса

После паузы приходится пересмотреть архитектуру. Ряд основопологающих моментов:
 - для хранения задач и результатов более целесообразным выглядит использование XML, более гибкий, а главное редактируемый вручную!
 - В каждом файле хранится описание объектов и объекты. Причем в описании в частности хранится ход прогресса. Т.е. через один файл реализуется возможность 
	- восстановления упавшего в ходе рассчетов результата
	- реализация параллелизма и блокировки 
	- PROFIT
 - в связи с этим новая архитектура должна выглядеть следующим образом:
 - HOP
	- __init__.py
	- __maie__.py
	- core.py - все связанное непосредственно с рассчетами. 
Необходим сервер состояния. Хранит метаинформацию, количество клонов (и сам клоны) всякие переменные
ВАЖНО! Похоже, что нам не нужно иметь коллектор клеток и древовидные структуры.
В питоне, когда на объект ничто не ссылается, то он удаляется из памяти. 
        - Engine -- собственно вся система. Запускается с параметрами определяющими работу системы.
Внутри енджин должны быть два блока. 
            - события генерирующие шаг времени, т.е. шаг ивентсервера
            - события принимающие шаг времени. Собирать ли их в одну пачку?        
        - EventServer
            - GetEvent
            - MakeEvent
На данный момент сервер событий организован в виде самоосортирующейся очереди (после вставки нового элемента)
Хотя надо переписать, что бы сортировка производилась перед возвращением элемента, возможно, это экономичней
Вся информация хранится в самой клетке, и о том что должно произойти и о том когда. 

Переделка на будущее: дело в том, что во время ожидания в очереди ситуация изменяется,
и она может влиять на скорость процессов. Отсюда необходимость делать поправку очереди.
Однако можно делать ленивый пересчет не после каждого такта, а только тогда,
когда среднее (минимальное?) время поправки превосходит зазоры в очереди. (это делается легко)
Кроме того, можно делать два стека событий и сортировать отдаленные редко, а потом забирать оттуда положим сотнями.
Но тут не вполне понятно как делать поправку.
        - Cell -- 
          - SetEventTime() -- кладем время до события
          - EventTime() -- время до события  
          - PerformEvent() -- выполнить событие. 
	- xml - интерфейс взаимодействия с памятью т.е. с XML 
		- пространство допустимых имен и их атрибутов. Строится фабрика создающая конкретный элемент. Т.е. по функции запичвающей каждый вид данных. Фабрика сосздает элементы фиксированной структуры. Для набирания бус, используется .append, который вставляет В тег. *
		- интерфейсы ввода
			- создания структуры данных
			- сохранения данных
				- метаинформации
				- экспериментов, в каком-то виде
		- интерфейсы вывода
			- чтения данных
				- метаинформации
				- обратной функции чтения данных
	- TaskServer - сервер задач. Наверное, надо прописывать его импорт прямо в ините. Не смог найти запуск библиотеки как приложения. Осуществялется это через __main__.py в котором прописывается запуск всех нужных модулей, и сервера соответственно
	- graph.py - модуль вывода графической информации
	- interface.py - совокупность интерфейсов -- ВОПРОС. надо ли оно мне
* Для XML-фабрики есть волшебная функция, выполняющая роль сериализатора списка. Т.к. фабрика понимает на входе как строку так и эелемент типа _element, то функция может спокойно использовать в построении фабрики.
>>> def a(l, f):
...  for i in range(len(l)):
...   f.append(l[i])
...  return f
ggg = d(a([d('1'),d('2')], d()))

Для пуша объектов в память используем str(), для извлечения используем eval()

===

В конечном итоге архитектура предпологается следующая:

- HOP 
	- __init__.py
	- model.py -- расчетное ядро
		- cell
		- clone
	- core.py -- менеджер задач, загружает ядро 
		- taskmeneger
		- Plan
	- graph.py
		- 


Судя по всему надо использовать к обычному питону еще библиотеки NumPy или шире SciPy, IPython & Mathplotlib
см. тут: http://stackoverflow.com/questions/17481672/fitting-a-weibull-distribution-using-scipy
С япитоном пока приостановил, видится слишком сложным. Для установки япитона на винду требуется поставить продукт Anaconda, который является каким-то коммерческим. Но судя по всему он в своиз 300ста мегах тягает все либы для научных вычислений.
Оказалось, что у него есть очень удобный, а что самое главное, очень понятный Spyder -- IDE.


hop
===

hematopoiesys on Python

Архитектура библиотек питона диктует двухуровневую иерархизацию. Т.е. в любом случае есть пакет, и есть егоо муодули. Из модулей мы можем подгружать функции. Однако, в __init__.py есть возможность прописать прямой импорт класса

После паузы приходится пересмотреть архитектуру. Ряд основопологающих моментов:
 - для хранения задач и результатов более целесообразным выглядит использование XML, более гибкий, а главное редактируемый вручную!
 - В каждом файле хранится описание объектов и объекты. Причем в описании в частности хранится ход прогресса. Т.е. через один файл реализуется возможность 
	- восстановления упавшего в ходе рассчетов результата
	- реализация параллелизма и блокировки 
	- PROFIT
 - в связи с этим новая архитектура должна выглядеть следующим образом:
 - HOP
	- __init__.py
	- __maie__.py
	- core.py - все связанное непосредственно с рассчетами. 
	- xml - интерфейс взаимодействия с памятью т.е. с XML 
		- пространство допустимых имен и их атрибутов. Строится фабрика создающая конкретный элемент. Т.е. по функции запичвающей каждый вид данных. Фабрика сосздает элементы фиксированной структуры. Для набирания бус, используется .append, который вставляет В тег. *
		- интерфейсы ввода
			- создания структуры данных
			- сохранения данных
				- метаинформации
				- экспериментов, в каком-то виде
		- интерфейсы вывода
			- чтения данных
				- метаинформации
				- обратной функции чтения данных
	- TaskServer - сервер задач. Наверное, надо прописывать его импорт прямо в ините. Не смог найти запуск библиотеки как приложения. Осуществялется это через __main__.py в котором прописывается запуск всех нужных модулей, и сервера соответственно
	- graph.py - модуль вывода графической информации
	- interface.py - совокупность интерфейсов -- ВОПРОС. надо ли оно мне
* Для XML-фабрики есть волшебная функция, выполняющая роль сериализатора списка. Т.к. фабрика понимает на входе как строку так и эелемент типа _element, то функция может спокойно использовать в построении фабрики.
>>> def a(l, f):
...  for i in range(len(l)):
...   f.append(l[i])
...  return f
ggg = d(a([d('1'),d('2')], d()))

Для пуша объектов в память используем str(), для извлечения используем eval()

===

В конечном итоге архитектура предпологается следующая:

- HOP 
	- __init__.py
	- model.py -- расчетное ядро
		- cell
		- clone
	- core.py -- менеджер задач, загружает ядро 
		- taskmeneger
		- Plan
	- graph.py
		- 


Судя по всему надо использовать к обычному питону еще библиотеки NumPy или шире SciPy, IPython & Mathplotlib
см. тут: http://stackoverflow.com/questions/17481672/fitting-a-weibull-distribution-using-scipy
С япитоном пока приостановил, видится слишком сложным. Для установки япитона на винду требуется поставить продукт Anaconda, который является каким-то коммерческим. Но судя по всему он в своиз 300ста мегах тягает все либы для научных вычислений.
Оказалось, что у него есть очень удобный, а что самое главное, очень понятный Spyder -- IDE.


hop
===

hematopoiesys on Python

Архитектура библиотек питона диктует двухуровневую иерархизацию. Т.е. в любом случае есть пакет, и есть егоо муодули. Из модулей мы можем подгружать функции. Однако, в __init__.py есть возможность прописать прямой импорт класса

После паузы приходится пересмотреть архитектуру. Ряд основопологающих моментов:
 - для хранения задач и результатов более целесообразным выглядит использование XML, более гибкий, а главное редактируемый вручную!
 - В каждом файле хранится описание объектов и объекты. Причем в описании в частности хранится ход прогресса. Т.е. через один файл реализуется возможность 
	- восстановления упавшего в ходе рассчетов результата
	- реализация параллелизма и блокировки 
	- PROFIT
 - в связи с этим новая архитектура должна выглядеть следующим образом:
 - HOP
	- __init__.py
	- __mine__.py
    - core - библиотека, т.е. просто папка, в ней все связанное непосредственно с рассчетами.
        Мейнидея такой структуры такая, что все, что не вызывается извне должно лежать в специальных либах.  
        - __init__.py -- то, что непосредственно ядро, и то, что вызывается из скрипта 
            - Engine -- собственно вся система. Запускается с параметрами определяющими работу системы.  
            Движок имеет три части, 
            1. подготовка структуры модели
            2. препрогонка с фиксированными обратными связями
            3. расчет.
                - события генерирующие шаг времени, т.е. шаг ивентсервера
                - события принимающие шаг времени.
        - MOb.py -- Modell Objects -- объекты собственно модели
            - Cell -- 
              - SetEventTime() -- кладем время до события
              - EventTime() -- время до события  
              - PerformEvent() -- выполнить событие. 
        - AOb.py -- Auxiliary Objects -- вспомогательные объекты
            - EventServer
                - GetEvent
                - MakeEvent

Мысль 0. По большому счету я могу не прописывать компартменты, а только правила
Тогда создание инфраструктуры задача анализватора правил
         

На данный момент сервер событий организован в виде самоосортирующейся очереди (после вставки нового элемента)
Хотя надо переписать, что бы сортировка производилась перед возвращением элемента, возможно, это экономичней
Вся информация хранится в самой клетке, и о том что должно произойти и о том когда. 

Переделка на будущее: дело в том, что во время ожидания в очереди ситуация изменяется,
и она может влиять на скорость процессов. Отсюда необходимость делать поправку очереди.
Однако можно делать ленивый пересчет не после каждого такта, а только тогда,
когда среднее (минимальное?) время поправки превосходит зазоры в очереди. (это делается легко)
Кроме того, можно делать два стека событий и сортировать отдаленные редко, а потом забирать оттуда положим сотнями.
Но тут не вполне понятно как делать поправку.

	- xml - интерфейс взаимодействия с памятью т.е. с XML 
		- пространство допустимых имен и их атрибутов. Строится фабрика создающая конкретный элемент. Т.е. по функции запичвающей каждый вид данных. Фабрика сосздает элементы фиксированной структуры. Для набирания бус, используется .append, который вставляет В тег. *
		- интерфейсы ввода
			- создания структуры данных
			- сохранения данных
				- метаинформации
				- экспериментов, в каком-то виде
		- интерфейсы вывода
			- чтения данных
				- метаинформации
				- обратной функции чтения данных
	- TaskServer - сервер задач. Наверное, надо прописывать его импорт прямо в ините. Не смог найти запуск библиотеки как приложения. Осуществялется это через __main__.py в котором прописывается запуск всех нужных модулей, и сервера соответственно
	- graph.py - модуль вывода графической информации
	- interface.py - совокупность интерфейсов -- ВОПРОС. надо ли оно мне

Общая архитектура:
Импортируем HOP в скрипт, выполнение скрипта и есть работа приложения. 
Скрипт делится на части, можно при запуске HOP спрашивать где, и создавать файл-шаблон.
Скрипт представляет собой последовательность процедур по определенному правилу.
Надо придумать как проверять правильность написанного скрипта. Какой-то препроцессор.
Часть 1. Описание архитектуры
    Создание связей между компартментами
    Задание правил предпрогонки
Часть 2. Препрогонка
    Блокировка изменения архитектуры модели, 
    запуск ивент-сервера, итератора и пр. на препрогонку
Часть 3. Собственно расчет.
Часть 4. Сохранееие, Вывод

Наверное не буду делать всякие защиты от дураков. Может даже блокиратор изменения архитектуры не надо.

Описание архитектуры осуществляется набором функций описывающих взаимодействие между компартментами
1. архитектура поклеточного описания. 
Расширяет класс клетки (не забывать указывать self, или сделать это в качествее обертки
 - как-то указываем что используем в качестве аргументов обратной связи. Или просто имеем набор показателей?
   - 1. События (Events) Состояние клетки . Вероятность и исход. Исход задается как функция (несколько принципиальных видов) от конечной точки назначения 
Видимо надо организовывать как 
    AddCondition(имя,[список условий],[список исходов])
    При этом, это должен быть метод в Engine, который потом передается в клетки при создании, например в виде вектора. Интересно, что можно присвоить значение переменной класса, потом создать несколько экземпляров. Расточительство памяти, кстати. Т.ч. держим  в енжине. И решатель там же.
2. архитектура непрерывных компартментов
 - формулы переходов. Очень гибкий механизм через eval(), фактически можно передавать как строку любую ерунду на питоне
 - формулы изменения собственного объема
* Для XML-фабрики есть волшебная функция, выполняющая роль сериализатора списка. Т.к. фабрика понимает на входе как строку так и эелемент типа _element, то функция может спокойно использовать в построении фабрики.
>>> def a(l, f):
...  for i in range(len(l)):
...   f.append(l[i])
...  return f
ggg = d(a([d('1'),d('2')], d()))

Для пуша объектов в память используем str(), для извлечения используем eval()

===

В конечном итоге архитектура предпологается следующая:

- HOP 
	- __init__.py
	- model.py -- расчетное ядро
		- cell
		- clone
	- core.py -- менеджер задач, загружает ядро 
		- taskmeneger
		- Plan
	- graph.py
		- 


Судя по всему надо использовать к обычному питону еще библиотеки NumPy или шире SciPy, IPython & Mathplotlib
см. тут: http://stackoverflow.com/questions/17481672/fitting-a-weibull-distribution-using-scipy
С япитоном пока приостановил, видится слишком сложным. Для установки япитона на винду требуется поставить продукт Anaconda, который является каким-то коммерческим. Но судя по всему он в своиз 300ста мегах тягает все либы для научных вычислений.
Оказалось, что у него есть очень удобный, а что самое главное, очень понятный Spyder -- IDE.

